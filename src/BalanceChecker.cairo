// ** BalanceChecker **
//
// A contract that is responsible for checking balances of some contract
// addresses, stored in an other contract. There is no balances stored in
// this contract. Only logic around those balances.
//

// Ok, seems that we can use top level use statments. But modules can't see that?
// TODO: to be checked.
use starknet::ContractAddress;

// Here, the interface related to the functionatlity we need
// to interact with.
// We don't have to know the contract address, we only want
// to define the interface we require to work with.
#[abi]
trait IBalanceStorer {
    #[view]
    fn balance_of(addr: ContractAddress) -> u256;
}


#[contract]
mod BalanceChecker {

    // Those two are auto-generated by #[abi] macro.
    use super::IBalanceStorerDispatcher;
    use super::IBalanceStorerDispatcherTrait;

    use starknet::ContractAddress;

    struct Storage {
        storer_addr: ContractAddress,
    }

    #[constructor]
    fn constructor(
        storer_addr_: ContractAddress
    ) {
        storer_addr::write(storer_addr_);
    }

    // This method can be seen as a "proxy". We are deporting
    // the balance retrieval to the storer contract.
    #[view]
    fn balance_of(addr: ContractAddress) -> u256 {
        // The syntax here is saying: Ok, I want to call a contract that
        // implements the IBalanceStorer interface. Here is its address,
        // and the method I want to call.
        // Under the hood, Cairo is converting all of this beautiful syntax to
        // the binary form of such arguments, to then use Starknet OS syscall and
        // interact with the other contract.
        // The dispatcher is auto-generated by the #[abi] macro.
        IBalanceStorerDispatcher { contract_address: storer_addr::read() }.balance_of(addr)
    }

}


#[cfg(test)]
mod tests {

    use super::BalanceChecker as BC;
    use debug::PrintTrait;
    use integer::u256_from_felt252;
    use starknet::ContractAddress;
    use starknet::contract_address_const;
    use starknet::testing::set_caller_address;

    #[test]
    #[available_gas(2000000)]
    fn init() {
        let storer_addr: ContractAddress = contract_address_const::<1>();
        BC::constructor(storer_addr);
    }

    #[test]
    #[available_gas(2000000)]
    fn balance_of() {
        // If we want to unit test this method, we have to mock somehow
        // the storer address.
        // As this function is more like a proxy, it's tested in integration tests.

        // let storer_addr: ContractAddress = contract_address_const::<1>();
        // BC::constructor(storer_addr);

        // let dest_addr: ContractAddress = contract_address_const::<2>();
        // BC::balance_of(dest_addr);
    }


}
